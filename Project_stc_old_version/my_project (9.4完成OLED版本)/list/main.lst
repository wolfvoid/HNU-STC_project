C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE source\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND 
                    -PRINT(.\list\main.lst) TABS(2) OBJECT(.\output\main.obj)

line level    source

   1          #include "main.h"
   2          
   3          //静音测试
   4          //void SetBeep(char a,char b);
   5          
   6          //用户自定义函数声明
   7          void Initial_interface();
   8          void myKey_callback();
   9          void my100mS_callback();
  10          void myKN_callback();
  11          void myVib_callback();
  12          unsigned int tem_calculate(unsigned int tem_adc);
  13          void oled_display();
  14                                   
  15          //用户程序全局变量定义
  16          char state;//操作系统此时的状态
  17          char previous_state;//陷入切换模式之前的状态
  18          char vib_old_state;//陷入Vib之前的状态
  19          //char maxstate=10;//state的最大编号，修改这个之后需要同时在main.h中修改两个数组//为节省空间，直接在程序里
             -改
  20          bit key_flag = 0;
  21          bit transfer = 0;//state切换时为1，切换后OLED变化后归为0。
  22          //这里是因为OLED若一直刷新，将导致LED闪烁，无法正常显示，OLED短时间内只能设置一次
  23          bit oled_change = 0;
  24          
  25          char count=0;//用于计数分割时间，达成闪烁效果
  26          
  27          //mode1:Clock实时时钟初始默认值
  28          code struct_DS1302_RTC rtc_origin = {0x30,0x32,0x11,0x25,0x7,0x2,0x23};//  秒 分 时 日 月 星期 年
  29          struct_DS1302_RTC rtc;
  30          char clock_mode = 0;//0-时分秒  1-年月日   2-星期
  31          
  32          //mode2:stopwatch秒表模式全局变量
  33          unsigned int time1=0,time2 = 0;  
  34          bit stopwatch_1=0,stopwatch_2 = 0;
  35          
  36          //mode3:timer定时器
  37          unsigned int timer = 3481;
  38          bit timer_change = 0;
  39          bit timer_minute = 0;
  40          bit timer_second = 0;
  41          bit timer_run = 0;
  42          
  43          //mode4：light_intensity
  44          char light_intensity_lowerlimit = 20;
  45          char light_intensity_upperlimit = 100;
  46          bit light_intensity_mode = 1;
  47          bit light_intensity_change = 0;
  48          bit light_intensity_lowerlimit_change = 0;
  49          bit light_intensity_upperlimit_change = 0;
  50          bit light_intensity_mode_change = 0;
  51          
  52          //mode5：temperature
  53          unsigned int temperature_lowerlimit = 200;
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 2   

  54          unsigned int temperature_upperlimit = 400;
  55          bit temperature_mode = 1;
  56          bit temperature_change = 0;
  57          bit temperature_lowerlimit_change = 0;
  58          bit temperature_upperlimit_change = 0;
  59          bit temperature_mode_change = 0;
  60          
  61          //mode6:FM收音机全局变量
  62          code struct_FMRadio radio_origin = {968,3,0,1,1};//频率*10 音量 灯 灯 灯 (0亮1灭)
  63          //107.0浙江广播 96.8浙江音乐广播
  64          bit FM_frequency = 0; //是否在调节频率
  65          bit FM_volume = 0;    //是否在调节音量
  66          bit FM_mutex = 0; //对于导航按键访问的锁
  67          
  68          //mode7:Mp3
  69          
  70          //mode8：RemoteControl
  71          
  72          //主函数
  73          void main() 
  74          { 
  75   1        //加载模块
  76   1        //Initialization
  77   1        KeyInit();
  78   1        BeepInit();
  79   1        OLED_Init();//启动OLED模块
  80   1        AdcInit(ADCexpEXT);//由于ADC模块自带对EXT口的控制，以该参数启动以解除控制，释放EXT口给OLED
  81   1        DisplayerInit();
  82   1        DS1302Init(rtc_origin);
  83   1        FMRadioInit(radio_origin);//FM收音机模块
  84   1        MusicPlayerInit();
  85   1        IrInit(NEC_R05d);
  86   1        VibInit();
  87   1        //UartInit();
  88   1        
  89   1      
  90   1        //设置事件回调函数
  91   1        SetEventCallBack(enumEventKey, myKey_callback);
  92   1        SetEventCallBack(enumEventSys100mS, my100mS_callback);
  93   1        SetEventCallBack(enumEventNav, myKN_callback);//负责导航键和K3键★★★的回调
  94   1        SetEventCallBack(enumEventVib, myVib_callback);
  95   1        
  96   1        //用户程序状态初始化
  97   1        
  98   1        
  99   1        //用户程序变量初始化
 100   1        state = 0;  
 101   1        previous_state = 0;
 102   1        vib_old_state = 0;
 103   1        Initial_interface();
 104   1        SetDisplayerArea(0,7);
 105   1        //RTC_Write(rtc_origin);  //修改系统时
 106   1        
 107   1        //OS主循环
 108   1        MySTC_Init();
 109   1        while(1)              
 110   1          {
 111   2            MySTC_OS();
 112   2            //用户主循环程序
 113   2          }
 114   1      }                 
 115          
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 3   

 116          //初始界面
 117          void Initial_interface()
 118          {
 119   1          OLED_DrawBMP(0, 0, 128, 8, BMP0);
 120   1          OLED_ShowString(0, 6, "HUNAN UNIVERSITY", 16);
 121   1          state=2;
 122   1      }
 123          
 124          //导航按键和K3按键的回调函数
 125          void myKN_callback()
 126          {
 127   1        char K3=GetAdcNavAct(enumAdcNavKey3);
 128   1        char up=GetAdcNavAct(enumAdcNavKeyUp);
 129   1        char down=GetAdcNavAct(enumAdcNavKeyDown);
 130   1        char left=GetAdcNavAct(enumAdcNavKeyLeft);
 131   1        char right=GetAdcNavAct(enumAdcNavKeyRight);
 132   1        
 133   1        //mode2: stopwatch1  秒表模式1
 134   1        if (state == 4)
 135   1        {
 136   2          if (K3 == enumKeyPress) 
 137   2           { 
 138   3             stopwatch_1 =~stopwatch_1; 
 139   3             if (stopwatch_1) time1=0; 
 140   3             SetBeep(1000,20);
 141   3           }
 142   2        }
 143   1        
 144   1        //mode3: timer-nav  定时器模式导航按键调节
 145   1        if (state == 5 && timer_change == 1)
 146   1        {
 147   2          if (up == enumKeyPress)
 148   2          {
 149   3            if (timer_minute == 1) timer += 600;
 150   3            else if (timer_second == 1) timer += 10;
 151   3            SetBeep(1000,20);
 152   3          }
 153   2          else if (down == enumKeyPress)
 154   2          {
 155   3            if (timer_minute == 1) if (timer-600 > 0) timer -= 600; else timer = 0;
 156   3            else if (timer_second == 1) if (timer-10 > 0) timer -= 10; else timer = 0;
 157   3            SetBeep(1000,20);
 158   3          }
 159   2          if (left == enumKeyPress)
 160   2          {
 161   3            if (timer_second == 1) {timer_second = 0; timer_minute = 1;}
 162   3            SetBeep(1000,20);
 163   3          }
 164   2          if (right == enumKeyPress)
 165   2          {
 166   3            if (timer_minute == 1) {timer_minute = 0; timer_second = 1;}
 167   3            SetBeep(1000,20);
 168   3          }
 169   2        }
 170   1        
 171   1        //mode3: timer 定时器模式(正常状态与计时状态转换)
 172   1        if (state == 5 && timer_change == 0)
 173   1        {
 174   2          if (K3  == enumKeyPress)
 175   2          {
 176   3            timer_run = ~timer_run;
 177   3          }
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 4   

 178   2        }
 179   1        
 180   1        //mode4: light_intensity_change
 181   1        if (state == 6 && light_intensity_change == 1)
 182   1        {
 183   2          if (up == enumKeyPress)
 184   2          {
 185   3            if (light_intensity_lowerlimit_change == 1) //下限增大
 186   3            {
 187   4              if (light_intensity_lowerlimit+1 < light_intensity_upperlimit) light_intensity_lowerlimit++;
 188   4            }
 189   3            else if (light_intensity_upperlimit_change == 1) //上限增大
 190   3            {
 191   4              if (light_intensity_upperlimit+1 < 255) light_intensity_upperlimit++;
 192   4            }
 193   3            else if (light_intensity_mode_change == 1) //修改模式
 194   3            {
 195   4              light_intensity_mode = ~light_intensity_mode;
 196   4            }
 197   3            SetBeep(1000,20);
 198   3          }
 199   2          else if (down == enumKeyPress)
 200   2          {
 201   3            if (light_intensity_lowerlimit_change == 1) //下限减小
 202   3            {
 203   4              if (light_intensity_lowerlimit-1 > 0) light_intensity_lowerlimit--;
 204   4            }
 205   3            else if (light_intensity_upperlimit_change == 1) //上限减小
 206   3            {
 207   4              if (light_intensity_upperlimit-1 > light_intensity_lowerlimit) light_intensity_upperlimit--;
 208   4            }
 209   3            else if (light_intensity_mode_change == 1) //修改模式
 210   3            {
 211   4              light_intensity_mode = ~light_intensity_mode;
 212   4            }
 213   3            SetBeep(1000,20);
 214   3          }
 215   2          if (left == enumKeyPress)
 216   2          {
 217   3            if (light_intensity_lowerlimit_change == 1) 
 218   3            {
 219   4              light_intensity_lowerlimit_change = 0;
 220   4              light_intensity_mode_change = 1;
 221   4            }
 222   3            if (light_intensity_upperlimit_change == 1) 
 223   3            {
 224   4              light_intensity_upperlimit_change = 0;
 225   4              light_intensity_lowerlimit_change = 1;
 226   4            }
 227   3            SetBeep(1000,20);
 228   3          }
 229   2          if (right == enumKeyPress)
 230   2          {
 231   3            if (light_intensity_lowerlimit_change == 1) 
 232   3            {
 233   4              light_intensity_lowerlimit_change = 0;
 234   4              light_intensity_upperlimit_change = 1;
 235   4            }
 236   3            if (light_intensity_mode_change == 1) 
 237   3            {
 238   4              light_intensity_mode_change = 0;
 239   4              light_intensity_lowerlimit_change = 1;
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 5   

 240   4            }
 241   3            SetBeep(1000,20);
 242   3          }
 243   2        }
 244   1        
 245   1        //mode5: temperature_change
 246   1        if (state == 7 && temperature_change == 1)
 247   1        {
 248   2          if (up == enumKeyPress)
 249   2          {
 250   3            if (temperature_lowerlimit_change == 1) //下限增大
 251   3            {
 252   4              if (temperature_lowerlimit+1 < temperature_upperlimit) temperature_lowerlimit++;
 253   4            }
 254   3            else if (temperature_upperlimit_change == 1) //上限增大
 255   3            {
 256   4              if (temperature_upperlimit+1 < 999) temperature_upperlimit++;
 257   4            }
 258   3            else if (temperature_mode_change == 1) //修改模式
 259   3            {
 260   4              temperature_mode = ~temperature_mode;
 261   4            }
 262   3            SetBeep(1000,20);
 263   3          }
 264   2          else if (down == enumKeyPress)
 265   2          {
 266   3            if (temperature_lowerlimit_change == 1) //下限减小
 267   3            {
 268   4              if (temperature_lowerlimit-1 > 0) temperature_lowerlimit--;
 269   4            }
 270   3            else if (temperature_upperlimit_change == 1) //上限减小
 271   3            {
 272   4              if (temperature_upperlimit-1 > temperature_lowerlimit) temperature_upperlimit--;
 273   4            }
 274   3            else if (temperature_mode_change == 1) //修改模式
 275   3            {
 276   4              temperature_mode = ~temperature_mode;
 277   4            }
 278   3            SetBeep(1000,20);
 279   3          }
 280   2          if (left == enumKeyPress)
 281   2          {
 282   3            if (temperature_lowerlimit_change == 1) 
 283   3            {
 284   4              temperature_lowerlimit_change = 0;
 285   4              temperature_mode_change = 1;
 286   4            }
 287   3            if (temperature_upperlimit_change == 1) 
 288   3            {
 289   4              temperature_upperlimit_change = 0;
 290   4              temperature_lowerlimit_change = 1;
 291   4            }
 292   3            SetBeep(1000,20);
 293   3          }
 294   2          if (right == enumKeyPress)
 295   2          {
 296   3            if (temperature_lowerlimit_change == 1) 
 297   3            {
 298   4              temperature_lowerlimit_change = 0;
 299   4              temperature_upperlimit_change = 1;
 300   4            }
 301   3            if (temperature_mode_change == 1) 
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 6   

 302   3            {
 303   4              temperature_mode_change = 0;
 304   4              temperature_lowerlimit_change = 1;
 305   4            }
 306   3            SetBeep(1000,20);
 307   3          }
 308   2        }
 309   1        
 310   1        //mode6: FM收音机模式(K3)
 311   1        if (state == 8)
 312   1        {
 313   2          if (K3 == enumKeyPress && FM_mutex == 0)//未选中状态进入选中状态
 314   2          {
 315   3            FM_mutex = 1;//获取锁
 316   3            FM_volume = 1;
 317   3            SetBeep(1500,20);
 318   3          }
 319   2          else if (K3 == enumKeyPress && FM_mutex == 1 && FM_volume == 1)//选中状态恢复未选中状态
 320   2          {
 321   3            FM_mutex = 0;//释放锁
 322   3            FM_volume = 0;
 323   3            SetBeep(1500,20);
 324   3          }
 325   2        }
 326   1        
 327   1        
 328   1        //mode6: FM收音机模式导航按键调节
 329   1        if (state == 8)
 330   1        {
 331   2          struct_FMRadio radio;
 332   2          radio.frequency = GetFMRadio().frequency;
 333   2          radio.volume = GetFMRadio().volume;
 334   2          radio.GP1 = GetFMRadio().GP1;
 335   2          radio.GP2 = GetFMRadio().GP2;
 336   2          radio.GP3 = GetFMRadio().GP3;
 337   2          if (up == enumKeyPress)
 338   2          {
 339   3            if (FM_frequency == 1) radio.frequency += 1;
 340   3            else if (FM_volume == 1) radio.volume += 1;
 341   3            SetBeep(1000,20);
 342   3          }
 343   2          else if (down == enumKeyPress)
 344   2          {
 345   3            if (FM_frequency == 1) radio.frequency -= 1;
 346   3            else if (FM_volume == 1) radio.volume -= 1;
 347   3            SetBeep(1000,20);
 348   3          }
 349   2          SetFMRadio(radio);
 350   2        }
 351   1        
 352   1      }
 353          
 354          
 355          //Key 按键触发回调函数
 356          void myKey_callback()
 357          { 
 358   1        char K1=GetKeyAct(enumKey1);
 359   1        char K2=GetKeyAct(enumKey2);
 360   1        //char K3=GetKeyAct(enumKey3);
 361   1        //char K3=GetAdcNavAct(enumAdcNavKey3);
 362   1        //特别注意：
 363   1        //由于导航按键与K3键共用了单片机同一个端口（P1.7），
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 7   

 364   1        //启用ADC模块后，P1.7口IO功能失效，
 365   1        //只能用GetAdcNavAct(char Nav_button)函数获取K3按键的事件或状态。
 366   1        
 367   1        if (K1 == enumKeyPress)
 368   1        {
 369   2          oled_change = 1;
 370   2        }
 371   1        
 372   1        //切换模式
 373   1        if (state != 0)//排除Vib模式
 374   1        {
 375   2          if (key_flag == 0 && K1 == enumKeyPress) 
 376   2          { 
 377   3            previous_state=state;//保存原状态
 378   3            state=1;
 379   3            key_flag=1;
 380   3          }
 381   2          else if (key_flag == 1 && K1 == enumKeyPress)
 382   2          {
 383   3            if (previous_state < 9) 
 384   3            {
 385   4              SetBeep(600,10);
 386   4              state=previous_state+1;//切换到下一个模式
 387   4              transfer=1;
 388   4            }
 389   3            else 
 390   3            {
 391   4              SetBeep(600,10);
 392   4              state=3;//模式到尽头，切换回开头
 393   4              transfer=1;
 394   4            }
 395   3            key_flag=0;
 396   3          }
 397   2        }
 398   1        else if (state == 0)
 399   1        {
 400   2          if (K1 == enumKeyPress)
 401   2          {
 402   3            state = vib_old_state;
 403   3          }
 404   2        }
 405   1        
 406   1        //mode1: 实时时钟模式-切换查看 时分秒/年月日/星期
 407   1        if (state == 3)
 408   1        {
 409   2          if (K2 == enumKeyPress)
 410   2          {
 411   3            if (clock_mode<2) clock_mode++;
 412   3            else clock_mode = 0;
 413   3          }
 414   2        }
 415   1      
 416   1        //mode2: 秒表模式2
 417   1        if (state == 4)
 418   1        {
 419   2          if (K2 == enumKeyPress)
 420   2          { 
 421   3            stopwatch_2 =~stopwatch_2; 
 422   3            if (stopwatch_2) time2=0; 
 423   3            SetBeep(1500,20);
 424   3          }
 425   2        }
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 8   

 426   1        
 427   1        //mode3: 定时器模式(normal state <=> change state)
 428   1        if (state == 5 && timer_run == 0)
 429   1        {
 430   2          if (K2 == enumKeyPress)
 431   2          {
 432   3            if (timer_change == 0) timer_second = 1;
 433   3            timer_change = ~timer_change;
 434   3          }
 435   2        }
 436   1        
 437   1        //mode4: 光感模式(normal state <=> change state)
 438   1        if (state == 6)
 439   1        {
 440   2          if (K2 == enumKeyPress)
 441   2          {
 442   3            light_intensity_change = ~light_intensity_change;
 443   3            light_intensity_lowerlimit_change = 1;
 444   3          }
 445   2        }
 446   1        
 447   1        //mode5: 温感模式(normal state <=> change state)
 448   1        if (state == 7)
 449   1        {
 450   2          if (K2 == enumKeyPress)
 451   2          {
 452   3            temperature_change = ~temperature_change;
 453   3            temperature_lowerlimit_change = 1;
 454   3          }
 455   2        }
 456   1        
 457   1        //mode6: FM收音机模式(K2)
 458   1        if (state == 8)
 459   1        {
 460   2          if (K2 == enumKeyPress && FM_mutex == 0)//未选中状态进入选中状态
 461   2          {
 462   3            FM_mutex = 1;//获取锁
 463   3            FM_frequency = 1;
 464   3            SetBeep(1500,20);
 465   3          }
 466   2          else if (K2 == enumKeyPress && FM_mutex == 1 && FM_frequency == 1)//选中状态恢复未选中状态
 467   2          {
 468   3            FM_mutex = 0;//释放锁
 469   3            FM_frequency = 0;
 470   3            SetBeep(1500,20);
 471   3          }
 472   2        }
 473   1        
 474   1        //mode7: MP3播放器
 475   1        if (state == 9)
 476   1        {
 477   2          if (K2 == enumKeyPress && GetPlayerMode() == enumModeStop)//停止状态，初次按下K2开始
 478   2          {
 479   3            SetMusic(90,0xFA,&song_TruE,sizeof(song_TruE),enumMscNull);
 480   3            //改动时注意两个要一起改动
 481   3            SetPlayerMode(enumModePlay);
 482   3          }
 483   2          else if (K2 == enumKeyPress && GetPlayerMode() == enumModePlay)//仍在播放，按下K2暂停
 484   2          {
 485   3            SetPlayerMode(enumModePause);
 486   3          }
 487   2          else if (K2 == enumKeyPress && GetPlayerMode() == enumModePause)//暂停状态，按下K2继续
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 9   

 488   2          {
 489   3            SetPlayerMode(enumModePlay);
 490   3          }
 491   2        }
 492   1        
 493   1        //mode7(end): 离开音乐播放模式，自动停止播放
 494   1        if (state != 9 && (GetPlayerMode() == enumModePause || GetPlayerMode() == enumModePlay))
 495   1          SetPlayerMode(enumModeStop);
 496   1        
 497   1        /*该功能废止
 498   1        //mode8: 遥控模式
 499   1        if (state == 10)
 500   1        {
 501   1          if (K2 == enumKeyPress)
 502   1          {
 503   1            if(IrTxdSet(&controller,22) == enumIrTxOK) SetBeep(1500,20);
 504   1          }
 505   1        }
 506   1        */
 507   1        
 508   1      }
 509          
 510          
 511          
 512          
 513          //定时回调函数(用于显示数码管)
 514          void my100mS_callback()
 515          { 
 516   1        if (oled_change == 1)
 517   1        {
 518   2          oled_display();
 519   2          oled_change = 0;
 520   2        }
 521   1        
 522   1        //秒表模式，在秒表模式之外也计时
 523   1        if(stopwatch_1 ==1)  time1++;
 524   1        if(stopwatch_2 ==1)  time2++;
 525   1        
 526   1        //定时器模式，在定时器之外也进行
 527   1        if (timer_run == 1 ) timer--;
 528   1        if (timer == 0 )
 529   1        {
 530   2          timer_run = 0;
 531   2          SetBeep(1400,200);
 532   2          timer = 3000;
 533   2          
 534   2        }
 535   1      
 536   1        switch(state)
 537   1        {
 538   2          
 539   2          
 540   2          //Vib处理模式界面
 541   2          case 0:
 542   2          {
 543   3            Seg7Print(30,13,1,11,11,1,13,30);
 544   3            break;
 545   3          }
 546   2          
 547   2          
 548   2          //切换模式界面
 549   2          case 1:
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 10  

 550   2          {
 551   3            if (transfer == 1)//state转移，需要改变屏幕
 552   3            {
 553   4              OLED_ShowString(0, 6, "Next Mode：", 16);
 554   4              transfer=0;
 555   4              oled_change=1;
 556   4            }
 557   3            Seg7Print(32,37,44,44,48,34,12,next_mode[previous_state]);
 558   3            LedPrint(0);
 559   3            break;
 560   3          }
 561   2          
 562   2          
 563   2          //初始欢迎界面:HNU-CSEE+流水灯
 564   2          case 2:
 565   2          {
 566   3            unsigned char a;
 567   3            Seg7Print(37,43,50,12,32,48,34,34);
 568   3          
 569   3            if( a != 0) a=a<<1;
 570   3              else a=0x01;
 571   3            LedPrint(a);
 572   3            break;
 573   3          }
 574   2          
 575   2          
 576   2          //Mode1:实时时钟
 577   2          //初始显示时间，使用K2键依次切换显示 时分秒/年月日/星期(英文+数字)
 578   2          case 3:
 579   2          {
 580   3            rtc = RTC_Read();
 581   3            switch(clock_mode)
 582   3            {
 583   4              case 0:
 584   4              {
 585   5                Seg7Print(rtc.hour/16,rtc.hour%16,12,rtc.minute/16,rtc.minute%16,12,rtc.second/16,rtc.second%16);
 586   5                break;
 587   5              }
 588   4              case 1:
 589   4              {
 590   5                Seg7Print(rtc.year/16,rtc.year%16,12,rtc.month/16,rtc.month%16,12,rtc.day/16,rtc.day%16);
 591   5                break;
 592   5              }
 593   4              case 2:
 594   4              {
 595   5                unsigned char weekday = rtc.week;
 596   5                switch(weekday)
 597   5                {
 598   6                  case 1:{Seg7Print(43,43,44,56,10,10,12,1); break;}
 599   6                  case 2:{Seg7Print(49,50,57,10,10,10,12,2); break;}
 600   6                  case 3:{Seg7Print(50,50,34,58,10,10,12,3); break;}
 601   6                  case 4:{Seg7Print(49,37,50,47,59,10,12,4); break;}
 602   6                  case 5:{Seg7Print(35,47,60,10,10,10,12,4); break;}
 603   6                  case 6:{Seg7Print(48,30,61,10,10,10,12,4); break;}
 604   6                  case 7:{Seg7Print(48,50,62,10,10,10,12,4); break;}
 605   6                }
 606   5                break;
 607   5              }
 608   4            }
 609   3            
 610   3            break;
 611   3          }
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 11  

 612   2          
 613   2          
 614   2          //Mode2:双通道秒表
 615   2          //使用K3/K2键分别独立记两个表，切换模式不影响计时，将在后台继续
 616   2          case 4:
 617   2          {
 618   3            unsigned char d0,d1,d2,d3,d4,d5,d6,d7;  
 619   3        
 620   3            d7 = (time1/1000)%10; if (d7 == 0) d7 = 10;
 621   3            d6 = (time1/100)%10;  if (d6 == 0) d6 = 10;
 622   3            d5 = (time1/10)%10+20;//这里要显示小数点
 623   3            d4 = (time1%10);  
 624   3            
 625   3            d3 = (time2/1000)%10; if (d3 == 0) d3 = 10;
 626   3            d2 = (time2/100)%10;  if (d2 == 0) d2 = 10;
 627   3            d1 = (time2/10)%10+20;//这里要显示小数点
 628   3            d0 = (time2%10);
 629   3            
 630   3            Seg7Print(d7,d6,d5,d4,d3,d2,d1,d0);
 631   3            
 632   3            break;
 633   3          }
 634   2          
 635   2          
 636   2          //Mode3:定时器
 637   2          case 5:
 638   2          {
 639   3            count++;
 640   3            if (count<=3)//用计数分割时间，达成闪烁效果
 641   3            {
 642   4              Seg7Print(10,10,timer/10/60/10,timer/10/60%10,12,timer/10%60/10,timer/10%60%10+20,timer%10);
 643   4            }
 644   3            else
 645   3            {
 646   4              if (timer_change == 0)//正常状态 或 计数模式
 647   4              {
 648   5                if (timer_run == 0) Seg7Print(10,10,timer/10/60/10,timer/10/60%10,12,timer/10%60/10,timer/10%60%10+20
             -,timer%10);
 649   5                else if (timer_run == 1) Seg7Print(45,10,timer/10/60/10,timer/10/60%10,12,timer/10%60/10,timer/10%60%
             -10+20,timer%10);
 650   5              }
 651   4              else if (timer_minute == 1)//调节分钟，分钟闪烁
 652   4              {
 653   5                Seg7Print(32,10,10,10,12,timer/10%60/10,timer/10%60%10+20,timer%10);
 654   5              }
 655   4              else if (timer_second == 1)//调节秒钟，秒钟闪烁
 656   4              {
 657   5                Seg7Print(32,10,timer/10/60/10,timer/10/60%10,12,10,10,10);
 658   5              }
 659   4            }
 660   3            if (count > 5) count=0;
 661   3            break;
 662   3          }
 663   2          
 664   2          
 665   2          //Mode4:光照监测与报警
 666   2          case 6:
 667   2          {
 668   3            unsigned int num = GetADC().Rop;  
 669   3            
 670   3            if (light_intensity_change == 0)//正常模式
 671   3            {
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 12  

 672   4              Seg7Print(34,4,12,10,10,num/100,num/10%10,num%10);
 673   4              if (light_intensity_mode == 1)
 674   4              {
 675   5                if (num < light_intensity_lowerlimit)
 676   5                {
 677   6                  SetBeep(1200,200);
 678   6                }
 679   5                else if (num > light_intensity_upperlimit)
 680   5                {
 681   6                  SetBeep(2000,200);
 682   6                }
 683   5              }
 684   4            }
 685   3            else if (light_intensity_change == 1)//change模式
 686   3            {
 687   4              count++;
 688   4        
 689   4              if (count<=3)//用计数分割时间，达成闪烁效果
 690   4              {
 691   5                Seg7Print(light_intensity_mode,
 692   5                          light_intensity_lowerlimit/100%10,
 693   5                          light_intensity_lowerlimit/10%10,
 694   5                          light_intensity_lowerlimit%10,
 695   5                          12,
 696   5                          light_intensity_upperlimit/100%10,
 697   5                          light_intensity_upperlimit/10%10,
 698   5                          light_intensity_upperlimit%10);
 699   5              }
 700   4              else
 701   4              {
 702   5                if (light_intensity_lowerlimit_change == 1) //下限改动
 703   5                {
 704   6                  Seg7Print(light_intensity_mode,
 705   6                          10,10,10,
 706   6                          12,
 707   6                          light_intensity_upperlimit/100%10,
 708   6                          light_intensity_upperlimit/10%10,
 709   6                          light_intensity_upperlimit%10);
 710   6                }
 711   5                else if (light_intensity_upperlimit_change == 1) //上限改动
 712   5                {
 713   6                  Seg7Print(light_intensity_mode,
 714   6                          light_intensity_lowerlimit/100%10,
 715   6                          light_intensity_lowerlimit/10%10,
 716   6                          light_intensity_lowerlimit%10,
 717   6                          12,
 718   6                          10,10,10);
 719   6                }
 720   5                else if (light_intensity_mode_change == 1) //模式改动
 721   5                {
 722   6                  Seg7Print(10,
 723   6                          light_intensity_lowerlimit/100%10,
 724   6                          light_intensity_lowerlimit/10%10,
 725   6                          light_intensity_lowerlimit%10,
 726   6                          12,
 727   6                          light_intensity_upperlimit/100%10,
 728   6                          light_intensity_upperlimit/10%10,
 729   6                          light_intensity_upperlimit%10);
 730   6                }
 731   5              }
 732   4              if (count > 5) count=0;
 733   4            }
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 13  

 734   3            
 735   3            break;
 736   3          }
 737   2          
 738   2          
 739   2          //Mode5:温度监测与报警
 740   2          case 7:
 741   2          {
 742   3            unsigned int tem_adc = GetADC().Rt;
 743   3            unsigned int tem = tem_calculate(tem_adc);
 744   3            
 745   3            if (temperature_change == 0)//正常模式
 746   3            {
 747   4              Seg7Print(34,5,12,10,10,tem/100%10,20+tem/10%10,tem%10);
 748   4              //第二位显示小数点
 749   4              if (temperature_mode == 1)
 750   4              {
 751   5                if (tem/10 < 20)
 752   5                {
 753   6                  SetBeep(1200,200);
 754   6                }
 755   5                else if (tem/10 > 40)
 756   5                {
 757   6                  SetBeep(2000,200);
 758   6                }
 759   5              }
 760   4            }
 761   3            else if (temperature_change == 1)//change模式
 762   3            {
 763   4              count++;
 764   4        
 765   4              if (count<=3)//用计数分割时间，达成闪烁效果
 766   4              {
 767   5                Seg7Print(temperature_mode,
 768   5                          temperature_lowerlimit/100%10,
 769   5                          20+temperature_lowerlimit/10%10,
 770   5                          temperature_lowerlimit%10,
 771   5                          12,
 772   5                          temperature_upperlimit/100%10,
 773   5                          20+temperature_upperlimit/10%10,
 774   5                          temperature_upperlimit%10);
 775   5              }
 776   4              else
 777   4              {
 778   5                if (temperature_lowerlimit_change == 1) //下限改动
 779   5                {
 780   6                  Seg7Print(temperature_mode,
 781   6                          10,10,10,
 782   6                          12,
 783   6                          temperature_upperlimit/100%10,
 784   6                          20+temperature_upperlimit/10%10,
 785   6                          temperature_upperlimit%10);
 786   6                }
 787   5                else if (temperature_upperlimit_change == 1) //上限改动
 788   5                {
 789   6                  Seg7Print(temperature_mode,
 790   6                          temperature_lowerlimit/100%10,
 791   6                          20+temperature_lowerlimit/10%10,
 792   6                          temperature_lowerlimit%10,
 793   6                          12,
 794   6                          10,10,10);
 795   6                }
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 14  

 796   5                else if (temperature_mode_change == 1) //模式改动
 797   5                {
 798   6                  Seg7Print(10,
 799   6                          temperature_lowerlimit/100%10,
 800   6                          20+temperature_lowerlimit/10%10,
 801   6                          temperature_lowerlimit%10,
 802   6                          12,
 803   6                          temperature_upperlimit/100%10,
 804   6                          20+temperature_upperlimit/10%10,
 805   6                          temperature_upperlimit%10);
 806   6                }
 807   5              }
 808   4              if (count > 5) count=0;
 809   4            }
 810   3            
 811   3              break;
 812   3          }
 813   2          
 814   2          
 815   2          //Mode6:FM收音机
 816   2          //按K1或K2进入选中状态，分别调节音量和频率，按上下导航键调节值大小
 817   2          case 8:
 818   2          {
 819   3            unsigned int frequency = GetFMRadio().frequency;
 820   3            unsigned char volume = GetFMRadio().volume;
 821   3            unsigned char fre0,fre1,fre2,vol0,vol1;
 822   3            fre0 = frequency%10;
 823   3            fre1 = frequency/10%10+20;
 824   3            fre2 = frequency/100%10; if (fre2 == 0) fre2 = 10;
 825   3            vol0 = volume%10;
 826   3            vol1 = volume/10%10;
 827   3            count++;
 828   3            if (count<=3)//用计数分割时间，达成闪烁效果
 829   3            {
 830   4              Seg7Print(50,vol1,vol0,10,35,fre2,fre1,fre0);
 831   4            }
 832   3            else
 833   3            {
 834   4              if (FM_frequency == 0 && FM_volume == 0)//正常情况
 835   4              {
 836   5                Seg7Print(50,vol1,vol0,10,35,fre2,fre1,fre0);
 837   5              }
 838   4              else if (FM_frequency == 1)//调节频率，频率闪烁
 839   4              {
 840   5                Seg7Print(50,vol1,vol0,10,35,10,10,10);
 841   5              }
 842   4              else if (FM_volume == 1)//调节音量，音量闪烁
 843   4              {
 844   5                Seg7Print(50,10,10,10,35,fre2,fre1,fre0);
 845   5              }
 846   4            }
 847   3            if (count > 5) count=0;
 848   3            break;
 849   3          }
 850   2          
 851   2          
 852   2          //Mode7:MP3
 853   2          case 9:
 854   2          {
 855   3            if (GetPlayerMode() == enumModeStop) Seg7Print(34,7,12,10,10,10,10,10);
 856   3            if (GetPlayerMode() == enumModePause) Seg7Print(45,30,50,48,34,10,10,10);
 857   3            break;
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 15  

 858   3          }
 859   2          
 860   2          /*该功能最后没有实现
 861   2          //Mode8:（格力）空调遥控
 862   2          case 10:
 863   2          {
 864   2            Seg7Print(12,12,43,44,12,8,12,12);
 865   2            break;
 866   2          }
 867   2          */
 868   2          
 869   2          default:
 870   2          {
 871   3            //do nothing
 872   3            break;
 873   3          }
 874   2          
 875   2        };
 876   1        
 877   1      }
 878          
 879          //震动事件回调函数
 880          void myVib_callback()
 881          {
 882   1        if (state != 0) vib_old_state = state;//加判断条件防止连续撞击导致state变为0，锁死出不去
 883   1        state = 0;
 884   1        SetBeep(600,10);
 885   1        oled_change = 1;
 886   1      }
 887          
 888          //温度转换辅助函数
 889          unsigned int tem_calculate(unsigned int tem_adc)
 890          {
 891   1        float vccx=tem_adc/1000.0;
 892   1        float lnx=log(vccx/(1-vccx));
 893   1        float tem=1/((lnx/3950)+(1/298.15))-273.15;
 894   1        float tem10=tem*10;
 895   1        unsigned int ans=(int)tem10;
 896   1        return ans;
 897   1      }
 898          
 899          //oled显示屏切换
 900          void oled_display()
 901          {
 902   1        OLED_Clear();
 903   1        OLED_ColorTurn(0);
 904   1        switch(state)
 905   1        {
 906   2          case 0:
 907   2          {
 908   3            //震动警告
 909   3            OLED_ShowString(0, 0, " MODE:01  CLOCK ", 16);
 910   3            OLED_ShowCHinese(64, 3, 29);
 911   3            OLED_ShowCHinese(80, 3, 30);
 912   3            OLED_ShowCHinese(96, 3, 31);
 913   3            OLED_ShowCHinese(112, 3, 32);
 914   3            break;
 915   3          }
 916   2          case 1:
 917   2          {
 918   3            //选择模式
 919   3            OLED_ShowString(0, 0, "CHOOSE YOUR MODE", 16);
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 16  

 920   3            OLED_ShowCHinese(64, 3, 33);
 921   3            OLED_ShowCHinese(80, 3, 34);
 922   3            OLED_ShowCHinese(96, 3, 35);
 923   3            OLED_ShowCHinese(112, 3, 36);
 924   3            break;
 925   3          }
 926   2          case 2:
 927   2          {
 928   3            //由初始化函数代为处理，此处不作操作
 929   3            break;
 930   3          }
 931   2          case 3:
 932   2          {
 933   3            //MODE-1 实时时钟
 934   3            OLED_DrawBMP1(0, 0, 64, 64, clock_avater);
 935   3            OLED_ShowString(0, 0, " MODE:01  CLOCK ", 16);
 936   3            OLED_ShowCHinese(64, 3, 0);
 937   3            OLED_ShowCHinese(80, 3, 1);
 938   3            OLED_ShowCHinese(96, 3, 2);
 939   3            OLED_ShowCHinese(112, 3, 3);
 940   3            break;
 941   3          }
 942   2          case 4:
 943   2          {
 944   3            //MODE-2 双通道秒表
 945   3            OLED_DrawBMP1(0, 0, 64, 64, stopwatch_avater);
 946   3            OLED_ShowString(0, 0, " MODE:02  TIMER ", 16);
 947   3            OLED_ShowCHinese(64, 3, 4);
 948   3            OLED_ShowCHinese(80, 3, 5);
 949   3            OLED_ShowCHinese(96, 3, 6);
 950   3            OLED_ShowCHinese(64, 5, 7);
 951   3            OLED_ShowCHinese(80, 5, 8);
 952   3            break;
 953   3          }
 954   2          case 5:
 955   2          {
 956   3            //MODE-3 定时器
 957   3            OLED_DrawBMP1(0, 0, 64, 64, timer_avater);
 958   3            OLED_ShowString(0, 0, " MODE:03  TIMER ", 16);
 959   3            OLED_ShowCHinese(64, 3, 9);
 960   3            OLED_ShowCHinese(80, 3, 10);
 961   3            OLED_ShowCHinese(96, 3, 11);
 962   3            break;
 963   3          }
 964   2          case 6:
 965   2          {
 966   3            //MODE-4 光感监测与报警
 967   3            OLED_DrawBMP1(0, 0, 64, 64, light_avater);
 968   3            OLED_ShowString(0, 0, " MODE:04  TIMER ", 16);
 969   3            OLED_ShowCHinese(64, 3, 12);
 970   3            OLED_ShowCHinese(80, 3, 13);
 971   3            OLED_ShowCHinese(96, 3, 14);
 972   3            OLED_ShowCHinese(112, 3, 15);
 973   3            OLED_ShowCHinese(64, 5, 16);
 974   3            OLED_ShowCHinese(80, 5, 17);
 975   3            OLED_ShowCHinese(96, 5, 18);
 976   3            break;
 977   3          }
 978   2          case 7:
 979   2          {
 980   3            //MODE-5 温度监测与报警
 981   3            OLED_DrawBMP1(0, 0, 64, 64, temperature_avater);
C51 COMPILER V9.54   MAIN                                                                  09/04/2023 17:34:34 PAGE 17  

 982   3            OLED_ShowString(0, 0, " MODE:05  TIMER ", 16);
 983   3            OLED_ShowCHinese(64, 3, 19);
 984   3            OLED_ShowCHinese(80, 3, 20);
 985   3            OLED_ShowCHinese(96, 3, 21);
 986   3            OLED_ShowCHinese(112, 3, 22);
 987   3            OLED_ShowCHinese(64, 5, 23);
 988   3            OLED_ShowCHinese(80, 5, 24);
 989   3            OLED_ShowCHinese(96, 5, 25);
 990   3            break;
 991   3          }
 992   2          case 8:
 993   2          {
 994   3            //MODE-6 收音机FM
 995   3            OLED_DrawBMP1(0, 0, 64, 64, FM_avater);
 996   3            OLED_ShowString(0, 0, " MODE:06  TIMER ", 16);
 997   3            OLED_ShowCHinese(64, 3, 26);
 998   3            OLED_ShowCHinese(80, 3, 27);
 999   3            OLED_ShowCHinese(96, 3, 28);
1000   3            break;
1001   3          }
1002   2          case 9:
1003   2          {
1004   3            //MODE-7 音乐
1005   3            OLED_ColorTurn(1);
1006   3            OLED_DrawBMP1(0, 0, 64, 64, music_avater);
1007   3            OLED_ShowString(0, 0, " MODE:07  TIMER ", 16);
1008   3            break;
1009   3          }
1010   2          default:
1011   2          {
1012   3            //do nothing
1013   3            break;
1014   3          }
1015   2        }
1016   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5037    ----
   CONSTANT SIZE    =   5763    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
