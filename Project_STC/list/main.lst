C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE source\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND 
                    -PRINT(.\list\main.lst) TABS(2) OBJECT(.\output\main.obj)

line level    source

   1          #include "main.h"
   2          
   3          //¾²Òô²âÊÔ£ºÓÃÓÚÔÚÍ¼Êé¹ÝµÈ°²¾²µÄµØ·½×ö²âÊÔ
   4          //·½·¨£º×¢ÊÍµôÏÂÃæµÄBeepInit();²¢½â³ý¸Ã¾ävoid SetBeep(char a,char b);µÄ×¢ÊÍ
   5          //void SetBeep(char a,char b);
   6          
   7          //ÓÃ»§×Ô¶¨Òåº¯ÊýÉùÃ÷
   8          void Initial_interface();//³õÊ¼½çÃæ
   9          void myKey_callback();//Key°´¼ü´¥·¢»Øµ÷º¯Êý
  10          void my100mS_callback();//¶¨Ê±»Øµ÷º¯Êý£¨ÓÃÓÚÏÔÊ¾ÊýÂë¹Ü£©
  11          void myKN_callback();//µ¼º½°´¼ü£¦K3°´¼üµÄ»Øµ÷º¯Êý
  12          void myVib_callback();//Õð¶¯ÊÂ¼þ»Øµ÷º¯Êý
  13          unsigned int tem_calculate(unsigned int tem_adc);//ÎÂ¶È×ª»»¸¨Öúº¯Êý
  14          void oled_display();//OLEDÏÔÊ¾ÆÁÇÐ»»
  15          void uart_callback();//Í¨ÐÅ½ÓÊÕ»Øµ÷º¯Êý
  16          void pc_preview();//¼ÆËã»úÕ¹Ê¾
  17          
  18          //ÓÃ»§³ÌÐòÈ«¾Ö±äÁ¿¶¨Òå
  19          char state;//²Ù×÷ÏµÍ³´ËÊ±µÄ×´Ì¬
  20          char previous_state;//ÏÝÈëÇÐ»»Ä£Ê½Ö®Ç°µÄ×´Ì¬
  21          char vib_old_state;//ÏÝÈëVibÖ®Ç°µÄ×´Ì¬
  22          //char maxstate=10;//stateµÄ×î´ó±àºÅ£¬ÐÞ¸ÄÕâ¸öÖ®ºóÐèÒªÍ¬Ê±ÔÚmain.hÖÐÐÞ¸ÄÁ½¸öÊý×é//Îª½ÚÊ¡¿Õ¼ä£¬Ö±½ÓÔÚ³ÌÐòÀï
             -¸Ä
  23          bit key_flag = 0;
  24          bit transfer = 0;//stateÇÐ»»Ê±Îª1£¬ÇÐ»»ºóOLED±ä»¯ºó¹éÎª0¡£
  25          //ÕâÀïÊÇÒòÎªOLEDÈôÒ»Ö±Ë¢ÐÂ£¬½«µ¼ÖÂLEDÉÁË¸£¬ÎÞ·¨Õý³£ÏÔÊ¾£¬OLED¶ÌÊ±¼äÄÚÖ»ÄÜÉèÖÃÒ»´Î
  26          bit oled_change = 0;
  27          
  28          char count=0;//ÓÃÓÚ¼ÆÊý·Ö¸îÊ±¼ä£¬´ï³ÉÉÁË¸Ð§¹û
  29          
  30          //mode1:ClockÊµÊ±Ê±ÖÓ³õÊ¼Ä¬ÈÏÖµ
  31          code struct_DS1302_RTC rtc_origin = {0x0,0x16,0x17,0x7,0x9,0x4,0x23};//  Ãë ·Ö Ê± ÈÕ ÔÂ ÐÇÆÚ Äê
  32          struct_DS1302_RTC rtc;
  33          char clock_mode = 0;//0-Ê±·ÖÃë  1-ÄêÔÂÈÕ   2-ÐÇÆÚ
  34          
  35          //mode2:stopwatchÃë±íÄ£Ê½È«¾Ö±äÁ¿
  36          unsigned int time1=0,time2 = 0;//ÀÛ»ýÁ¿£ºÁ½¸öÃë±í·Ö±ð¼ÆÊ±µÄÖµ¡£
  37          bit stopwatch_1=0,stopwatch_2 = 0;//ÐÅºÅÁ¿£ºÁ½¸öÃë±íµÄ×´Ì¬£¬ÊÇ·ñ¿ªÊ¼¼ÆÊ±¡£¸ÃÐÅºÅÁ¿Îª1Ê±£¬¶¨Ê±»Øµ÷º¯Êý±»µ÷Ó
             -ÃÊ±»áÀÛ¼ÓÊ±¼ä¡£
  38          
  39          //mode3:timer¶¨Ê±Æ÷
  40          int timer = 3481;//×¢ÒâÕâÀïÎªÊ²Ã´²»ÄÜÓÃunsigned int
  41          //³õÊ¼¶¨Ê±Ê±¼ä£¨Ä¬ÈÏÖµÔÚÕâÀïÉèÖÃ£©
  42          bit timer_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬£¬³õÊ¼²»ÔÚchangeÌ¬
  43          bit timer_minute = 0;//µ±Ç°ÊÇ·ñÔÚchangeÌ¬µÄµ÷½Ú¡°·Ö¡±
  44          bit timer_second = 0;//µ±Ç°ÊÇ·ñÔÚchangeÌ¬µÄµ÷½Ú¡°Ãë¡±
  45          bit timer_run = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚ¡°¼ÆÊ±Ì¬¡±
  46          
  47          //mode4£ºlight_intensity
  48          char light_intensity_lowerlimit = 20;//¹âÕÕ±¨¾¯ÖµÏÂãÐÖµ
  49          char light_intensity_upperlimit = 100;//¹âÕÕ±¨¾¯ÖµÉÏãÐÖµ
  50          bit light_intensity_mode = 1;//¹âÕÕ±¨¾¯Ä£Ê½£¨ÊÇ·ñ±¨¾¯£¬Ä¬ÈÏ±¨¾¯£©
  51          bit light_intensity_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬
  52          bit light_intensity_lowerlimit_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬µÄµ÷½Ú¡°ÏÂãÐÖµ¡±
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 2   

  53          bit light_intensity_upperlimit_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬µÄµ÷½Ú¡°ÉÏãÐÖµ¡±
  54          bit light_intensity_mode_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬µÄµ÷½Ú¡°±¨¾¯Ä£Ê½¡±
  55          
  56          //mode5£ºtemperature
  57          unsigned int temperature_lowerlimit = 200;//ÎÂ¶È±¨¾¯ÖµÏÂãÐÖµ
  58          unsigned int temperature_upperlimit = 400;//ÎÂ¶È±¨¾¯ÖµÉÏãÐÖµ
  59          bit temperature_mode = 1;//ÎÂ¸Ð±¨¾¯Ä£Ê½£¨ÊÇ·ñ±¨¾¯£¬Ä¬ÈÏ±¨¾¯£©
  60          bit temperature_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬
  61          bit temperature_lowerlimit_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬µÄµ÷½Ú¡°ÏÂãÐÖµ¡±
  62          bit temperature_upperlimit_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬µÄµ÷½Ú¡°ÉÏãÐÖµ¡±
  63          bit temperature_mode_change = 0;//µ±Ç°ÊÇ·ñ´¦ÓÚchangeÌ¬µÄµ÷½Ú¡°±¨¾¯Ä£Ê½¡±
  64          
  65          //mode6:FMÊÕÒô»úÈ«¾Ö±äÁ¿
  66          code struct_FMRadio radio_origin = {886,3,0,1,1};//ÆµÂÊ*10 ÒôÁ¿ µÆ µÆ µÆ (0ÁÁ1Ãð)
  67          //107.0Õã½­¹ã²¥ 96.8Õã½­ÒôÀÖ¹ã²¥
  68          //88.6³¤É³ÒôÀÖ¹ã²¥ 89.3ºþÄÏÒôÀÖÖ®Éù
  69          bit FM_frequency = 0; //ÊÇ·ñÔÚµ÷½ÚÆµÂÊ
  70          bit FM_volume = 0;    //ÊÇ·ñÔÚµ÷½ÚÒôÁ¿
  71          bit FM_mutex = 0; //¶ÔÓÚµ¼º½°´¼ü·ÃÎÊµÄËø
  72          
  73          //mode7:Mp3
  74          
  75          //mode8£ºRemoteControl
  76          
  77          //Óë¼ÆËã»úÍ¨ÐÅ
  78          code char datahead[]={0xaa,0x55};//°üÍ·
  79          char datanow[];//½ÓÊÕÊý¾Ý±£´æµØÖ·
  80          code char back[]={0xaa,0x55,0xa1,0xa1,0xa1,0xa1};//³õ´ÎÍ¨Ñ¶·µ»ØÖµ
  81          
  82          //Ö÷º¯Êý
  83          void main()
  84          {
  85   1        //¼ÓÔØÄ£¿é
  86   1        //Initialization
  87   1        KeyInit();
  88   1        BeepInit();//¾²Òô²âÊÔÊ±×¢ÊÍ´Ë¾ä
  89   1        OLED_Init();//Æô¶¯OLEDÄ£¿é
  90   1        AdcInit(ADCexpEXT);//ÓÉÓÚADCÄ£¿é×Ô´ø¶ÔEXT¿ÚµÄ¿ØÖÆ£¬ÒÔ¸Ã²ÎÊýÆô¶¯ÒÔ½â³ý¿ØÖÆ£¬ÊÍ·ÅEXT¿Ú¸øOLED
  91   1        DisplayerInit();
  92   1        DS1302Init(rtc_origin);
  93   1        FMRadioInit(radio_origin);//FMÊÕÒô»úÄ£¿é
  94   1        MusicPlayerInit();
  95   1        //IrInit(NEC_R05d);
  96   1        VibInit();
  97   1        Uart1Init(1200);
  98   1        SetUart1Rxd(datanow,6,datahead,0);
  99   1      
 100   1      
 101   1        //ÉèÖÃÊÂ¼þ»Øµ÷º¯Êý
 102   1        SetEventCallBack(enumEventKey, myKey_callback);
 103   1        SetEventCallBack(enumEventSys100mS, my100mS_callback);
 104   1        SetEventCallBack(enumEventNav, myKN_callback);//¸ºÔðµ¼º½¼üºÍK3¼ü¡ï¡ï¡ïµÄ»Øµ÷
 105   1        SetEventCallBack(enumEventVib, myVib_callback);
 106   1        SetEventCallBack(enumEventUart1Rxd,uart_callback);
 107   1      
 108   1        //ÓÃ»§³ÌÐò×´Ì¬³õÊ¼»¯
 109   1      
 110   1      
 111   1        //ÓÃ»§³ÌÐò±äÁ¿³õÊ¼»¯
 112   1        state = 0;
 113   1        previous_state = 0;
 114   1        vib_old_state = 0;
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 3   

 115   1        Initial_interface();
 116   1        SetDisplayerArea(0,7);
 117   1        //RTC_Write(rtc_origin);  //ÐÞ¸ÄÏµÍ³Ê±
 118   1      
 119   1        //OSÖ÷Ñ­»·
 120   1        MySTC_Init();
 121   1        while(1)
 122   1          {
 123   2            MySTC_OS();
 124   2            //ÓÃ»§Ö÷Ñ­»·³ÌÐò
 125   2          }
 126   1      }
 127          
 128          //³õÊ¼½çÃæ
 129          void Initial_interface()
 130          {
 131   1          OLED_DrawBMP(0, 0, 128, 8, BMP0);
 132   1          OLED_ShowString(0, 6, "HUNAN UNIVERSITY", 16);
 133   1          state=2;
 134   1      }
 135          
 136          //µ¼º½°´¼üºÍK3°´¼üµÄ»Øµ÷º¯Êý
 137          void myKN_callback()
 138          {
 139   1        char K3=GetAdcNavAct(enumAdcNavKey3);
 140   1        char up=GetAdcNavAct(enumAdcNavKeyUp);
 141   1        char down=GetAdcNavAct(enumAdcNavKeyDown);
 142   1        char left=GetAdcNavAct(enumAdcNavKeyLeft);
 143   1        char right=GetAdcNavAct(enumAdcNavKeyRight);
 144   1      
 145   1        //mode2: stopwatch1  Ãë±íÄ£Ê½1
 146   1        if (state == 4)
 147   1        {
 148   2          if (K3 == enumKeyPress)
 149   2           {
 150   3             stopwatch_1 =~stopwatch_1;
 151   3             if (stopwatch_1) time1=0;
 152   3             SetBeep(1000,20);
 153   3           }
 154   2        }
 155   1      
 156   1        //mode3: timer-nav  ¶¨Ê±Æ÷Ä£Ê½µ¼º½°´¼üµ÷½Ú
 157   1        if (state == 5 && timer_change == 1)
 158   1        {
 159   2          if (up == enumKeyPress)
 160   2          {
 161   3            if (timer_minute == 1) timer += 600;
 162   3            else if (timer_second == 1) timer += 10;
 163   3            SetBeep(1000,20);
 164   3          }
 165   2          else if (down == enumKeyPress)
 166   2          {
 167   3            if (timer_minute == 1) if (timer-600 > 0) timer -= 600; else timer = 0;
 168   3            else if (timer_second == 1) if (timer-10 > 0) timer -= 10; else timer = 0;
 169   3            SetBeep(1000,20);
 170   3          }
 171   2          if (left == enumKeyPress)
 172   2          {
 173   3            if (timer_second == 1) {timer_second = 0; timer_minute = 1;}
 174   3            SetBeep(1000,20);
 175   3          }
 176   2          if (right == enumKeyPress)
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 4   

 177   2          {
 178   3            if (timer_minute == 1) {timer_minute = 0; timer_second = 1;}
 179   3            SetBeep(1000,20);
 180   3          }
 181   2        }
 182   1      
 183   1        //mode3: timer ¶¨Ê±Æ÷Ä£Ê½(Õý³£×´Ì¬Óë¼ÆÊ±×´Ì¬×ª»»)
 184   1        if (state == 5 && timer_change == 0)
 185   1        {
 186   2          if (K3  == enumKeyPress)
 187   2          {
 188   3            timer_run = ~timer_run;
 189   3          }
 190   2        }
 191   1      
 192   1        //mode4: light_intensity_change
 193   1        if (state == 6 && light_intensity_change == 1)
 194   1        {
 195   2          if (up == enumKeyPress)
 196   2          {
 197   3            if (light_intensity_lowerlimit_change == 1) //ÏÂÏÞÔö´ó
 198   3            {
 199   4              if (light_intensity_lowerlimit+1 < light_intensity_upperlimit) light_intensity_lowerlimit++;
 200   4            }
 201   3            else if (light_intensity_upperlimit_change == 1) //ÉÏÏÞÔö´ó
 202   3            {
 203   4              if (light_intensity_upperlimit+1 < 255) light_intensity_upperlimit++;
 204   4            }
 205   3            else if (light_intensity_mode_change == 1) //ÐÞ¸ÄÄ£Ê½
 206   3            {
 207   4              light_intensity_mode = ~light_intensity_mode;
 208   4            }
 209   3            SetBeep(1000,20);
 210   3          }
 211   2          else if (down == enumKeyPress)
 212   2          {
 213   3            if (light_intensity_lowerlimit_change == 1) //ÏÂÏÞ¼õÐ¡
 214   3            {
 215   4              if (light_intensity_lowerlimit-1 > 0) light_intensity_lowerlimit--;
 216   4            }
 217   3            else if (light_intensity_upperlimit_change == 1) //ÉÏÏÞ¼õÐ¡
 218   3            {
 219   4              if (light_intensity_upperlimit-1 > light_intensity_lowerlimit) light_intensity_upperlimit--;
 220   4            }
 221   3            else if (light_intensity_mode_change == 1) //ÐÞ¸ÄÄ£Ê½
 222   3            {
 223   4              light_intensity_mode = ~light_intensity_mode;
 224   4            }
 225   3            SetBeep(1000,20);
 226   3          }
 227   2          if (left == enumKeyPress)
 228   2          {
 229   3            if (light_intensity_lowerlimit_change == 1)
 230   3            {
 231   4              light_intensity_lowerlimit_change = 0;
 232   4              light_intensity_mode_change = 1;
 233   4            }
 234   3            if (light_intensity_upperlimit_change == 1)
 235   3            {
 236   4              light_intensity_upperlimit_change = 0;
 237   4              light_intensity_lowerlimit_change = 1;
 238   4            }
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 5   

 239   3            SetBeep(1000,20);
 240   3          }
 241   2          if (right == enumKeyPress)
 242   2          {
 243   3            if (light_intensity_lowerlimit_change == 1)
 244   3            {
 245   4              light_intensity_lowerlimit_change = 0;
 246   4              light_intensity_upperlimit_change = 1;
 247   4            }
 248   3            if (light_intensity_mode_change == 1)
 249   3            {
 250   4              light_intensity_mode_change = 0;
 251   4              light_intensity_lowerlimit_change = 1;
 252   4            }
 253   3            SetBeep(1000,20);
 254   3          }
 255   2        }
 256   1      
 257   1        //mode5: temperature_change
 258   1        if (state == 7 && temperature_change == 1)
 259   1        {
 260   2          if (up == enumKeyPress)
 261   2          {
 262   3            if (temperature_lowerlimit_change == 1) //ÏÂÏÞÔö´ó
 263   3            {
 264   4              if (temperature_lowerlimit+1 < temperature_upperlimit) temperature_lowerlimit++;
 265   4            }
 266   3            else if (temperature_upperlimit_change == 1) //ÉÏÏÞÔö´ó
 267   3            {
 268   4              if (temperature_upperlimit+1 < 999) temperature_upperlimit++;
 269   4            }
 270   3            else if (temperature_mode_change == 1) //ÐÞ¸ÄÄ£Ê½
 271   3            {
 272   4              temperature_mode = ~temperature_mode;
 273   4            }
 274   3            SetBeep(1000,20);
 275   3          }
 276   2          else if (down == enumKeyPress)
 277   2          {
 278   3            if (temperature_lowerlimit_change == 1) //ÏÂÏÞ¼õÐ¡
 279   3            {
 280   4              if (temperature_lowerlimit-1 > 0) temperature_lowerlimit--;
 281   4            }
 282   3            else if (temperature_upperlimit_change == 1) //ÉÏÏÞ¼õÐ¡
 283   3            {
 284   4              if (temperature_upperlimit-1 > temperature_lowerlimit) temperature_upperlimit--;
 285   4            }
 286   3            else if (temperature_mode_change == 1) //ÐÞ¸ÄÄ£Ê½
 287   3            {
 288   4              temperature_mode = ~temperature_mode;
 289   4            }
 290   3            SetBeep(1000,20);
 291   3          }
 292   2          if (left == enumKeyPress)
 293   2          {
 294   3            if (temperature_lowerlimit_change == 1)
 295   3            {
 296   4              temperature_lowerlimit_change = 0;
 297   4              temperature_mode_change = 1;
 298   4            }
 299   3            if (temperature_upperlimit_change == 1)
 300   3            {
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 6   

 301   4              temperature_upperlimit_change = 0;
 302   4              temperature_lowerlimit_change = 1;
 303   4            }
 304   3            SetBeep(1000,20);
 305   3          }
 306   2          if (right == enumKeyPress)
 307   2          {
 308   3            if (temperature_lowerlimit_change == 1)
 309   3            {
 310   4              temperature_lowerlimit_change = 0;
 311   4              temperature_upperlimit_change = 1;
 312   4            }
 313   3            if (temperature_mode_change == 1)
 314   3            {
 315   4              temperature_mode_change = 0;
 316   4              temperature_lowerlimit_change = 1;
 317   4            }
 318   3            SetBeep(1000,20);
 319   3          }
 320   2        }
 321   1      
 322   1        //mode6: FMÊÕÒô»úÄ£Ê½(K3)
 323   1        if (state == 8)
 324   1        {
 325   2          if (K3 == enumKeyPress && FM_mutex == 0)//Î´Ñ¡ÖÐ×´Ì¬½øÈëÑ¡ÖÐ×´Ì¬
 326   2          {
 327   3            FM_mutex = 1;//»ñÈ¡Ëø
 328   3            FM_volume = 1;
 329   3            SetBeep(1500,20);
 330   3          }
 331   2          else if (K3 == enumKeyPress && FM_mutex == 1 && FM_volume == 1)//Ñ¡ÖÐ×´Ì¬»Ö¸´Î´Ñ¡ÖÐ×´Ì¬
 332   2          {
 333   3            FM_mutex = 0;//ÊÍ·ÅËø
 334   3            FM_volume = 0;
 335   3            SetBeep(1500,20);
 336   3          }
 337   2        }
 338   1      
 339   1      
 340   1        //mode6: FMÊÕÒô»úÄ£Ê½µ¼º½°´¼üµ÷½Ú
 341   1        if (state == 8)
 342   1        {
 343   2          struct_FMRadio radio;
 344   2          radio.frequency = GetFMRadio().frequency;
 345   2          radio.volume = GetFMRadio().volume;
 346   2          radio.GP1 = GetFMRadio().GP1;
 347   2          radio.GP2 = GetFMRadio().GP2;
 348   2          radio.GP3 = GetFMRadio().GP3;
 349   2          if (up == enumKeyPress)
 350   2          {
 351   3            if (FM_frequency == 1) radio.frequency += 1;
 352   3            else if (FM_volume == 1) radio.volume += 1;
 353   3            SetBeep(1000,20);
 354   3          }
 355   2          else if (down == enumKeyPress)
 356   2          {
 357   3            if (FM_frequency == 1) radio.frequency -= 1;
 358   3            else if (FM_volume == 1) radio.volume -= 1;
 359   3            SetBeep(1000,20);
 360   3          }
 361   2          SetFMRadio(radio);
 362   2        }
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 7   

 363   1      
 364   1      }
 365          
 366          
 367          //Key °´¼ü´¥·¢»Øµ÷º¯Êý
 368          void myKey_callback()
 369          {
 370   1        char K1=GetKeyAct(enumKey1);
 371   1        char K2=GetKeyAct(enumKey2);
 372   1        //char K3=GetKeyAct(enumKey3);
 373   1        //char K3=GetAdcNavAct(enumAdcNavKey3);
 374   1        //ÌØ±ð×¢Òâ£º
 375   1        //ÓÉÓÚµ¼º½°´¼üÓëK3¼ü¹²ÓÃÁËµ¥Æ¬»úÍ¬Ò»¸ö¶Ë¿Ú£¨P1.7£©£¬
 376   1        //ÆôÓÃADCÄ£¿éºó£¬P1.7¿ÚIO¹¦ÄÜÊ§Ð§£¬
 377   1        //Ö»ÄÜÓÃGetAdcNavAct(char Nav_button)º¯Êý»ñÈ¡K3°´¼üµÄÊÂ¼þ»ò×´Ì¬¡£
 378   1      
 379   1        if (K1 == enumKeyPress)
 380   1        {
 381   2          oled_change = 1;
 382   2        }
 383   1      
 384   1        //ÇÐ»»Ä£Ê½
 385   1        if (state != 0)//ÅÅ³ýVibÄ£Ê½
 386   1        {
 387   2          if (key_flag == 0 && K1 == enumKeyPress)
 388   2          {
 389   3            previous_state=state;//±£´æÔ­×´Ì¬
 390   3            state=1;
 391   3            key_flag=1;
 392   3          }
 393   2          else if (key_flag == 1 && K1 == enumKeyPress)
 394   2          {
 395   3            if (previous_state < 9)
 396   3            {
 397   4              SetBeep(600,10);
 398   4              state=previous_state+1;//ÇÐ»»µ½ÏÂÒ»¸öÄ£Ê½
 399   4              transfer=1;
 400   4            }
 401   3            else
 402   3            {
 403   4              SetBeep(600,10);
 404   4              state=3;//Ä£Ê½µ½¾¡Í·£¬ÇÐ»»»Ø¿ªÍ·
 405   4              transfer=1;
 406   4            }
 407   3            key_flag=0;
 408   3          }
 409   2        }
 410   1        else if (state == 0)
 411   1        {
 412   2          if (K1 == enumKeyPress)
 413   2          {
 414   3            state = vib_old_state;
 415   3          }
 416   2        }
 417   1      
 418   1        //mode1: ÊµÊ±Ê±ÖÓÄ£Ê½-ÇÐ»»²é¿´ Ê±·ÖÃë/ÄêÔÂÈÕ/ÐÇÆÚ
 419   1        if (state == 3)
 420   1        {
 421   2          if (K2 == enumKeyPress)
 422   2          {
 423   3            if (clock_mode<2) clock_mode++;
 424   3            else clock_mode = 0;
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 8   

 425   3          }
 426   2        }
 427   1      
 428   1        //mode2: Ãë±íÄ£Ê½2
 429   1        if (state == 4)
 430   1        {
 431   2          if (K2 == enumKeyPress)
 432   2          {
 433   3            stopwatch_2 =~stopwatch_2;
 434   3            if (stopwatch_2) time2=0;
 435   3            SetBeep(1500,20);
 436   3          }
 437   2        }
 438   1      
 439   1        //mode3: ¶¨Ê±Æ÷Ä£Ê½(normal state <=> change state)
 440   1        if (state == 5 && timer_run == 0)
 441   1        {
 442   2          if (K2 == enumKeyPress)
 443   2          {
 444   3            if (timer_change == 0) timer_second = 1;
 445   3            timer_change = ~timer_change;
 446   3          }
 447   2        }
 448   1      
 449   1        //mode4: ¹â¸ÐÄ£Ê½(normal state <=> change state)
 450   1        if (state == 6)
 451   1        {
 452   2          if (K2 == enumKeyPress)
 453   2          {
 454   3            light_intensity_change = ~light_intensity_change;
 455   3            light_intensity_lowerlimit_change = 1;
 456   3          }
 457   2        }
 458   1      
 459   1        //mode5: ÎÂ¸ÐÄ£Ê½(normal state <=> change state)
 460   1        if (state == 7)
 461   1        {
 462   2          if (K2 == enumKeyPress)
 463   2          {
 464   3            temperature_change = ~temperature_change;
 465   3            temperature_lowerlimit_change = 1;
 466   3          }
 467   2        }
 468   1      
 469   1        //mode6: FMÊÕÒô»úÄ£Ê½(K2)
 470   1        if (state == 8)
 471   1        {
 472   2          if (K2 == enumKeyPress && FM_mutex == 0)//Î´Ñ¡ÖÐ×´Ì¬½øÈëÑ¡ÖÐ×´Ì¬
 473   2          {
 474   3            FM_mutex = 1;//»ñÈ¡Ëø
 475   3            FM_frequency = 1;
 476   3            SetBeep(1500,20);
 477   3          }
 478   2          else if (K2 == enumKeyPress && FM_mutex == 1 && FM_frequency == 1)//Ñ¡ÖÐ×´Ì¬»Ö¸´Î´Ñ¡ÖÐ×´Ì¬
 479   2          {
 480   3            FM_mutex = 0;//ÊÍ·ÅËø
 481   3            FM_frequency = 0;
 482   3            SetBeep(1500,20);
 483   3          }
 484   2        }
 485   1      
 486   1        //mode7: MP3²¥·ÅÆ÷
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 9   

 487   1        if (state == 9)
 488   1        {
 489   2          if (K2 == enumKeyPress && GetPlayerMode() == enumModeStop)//Í£Ö¹×´Ì¬£¬³õ´Î°´ÏÂK2¿ªÊ¼
 490   2          {
 491   3            SetMusic(90,0xFA,&song_TruE,sizeof(song_TruE),enumMscNull);
 492   3            //¸Ä¶¯Ê±×¢ÒâÁ½¸öÒªÒ»Æð¸Ä¶¯
 493   3            SetPlayerMode(enumModePlay);
 494   3          }
 495   2          else if (K2 == enumKeyPress && GetPlayerMode() == enumModePlay)//ÈÔÔÚ²¥·Å£¬°´ÏÂK2ÔÝÍ£
 496   2          {
 497   3            SetPlayerMode(enumModePause);
 498   3          }
 499   2          else if (K2 == enumKeyPress && GetPlayerMode() == enumModePause)//ÔÝÍ£×´Ì¬£¬°´ÏÂK2¼ÌÐø
 500   2          {
 501   3            SetPlayerMode(enumModePlay);
 502   3          }
 503   2        }
 504   1      
 505   1        //mode7(end): Àë¿ªÒôÀÖ²¥·ÅÄ£Ê½£¬×Ô¶¯Í£Ö¹²¥·Å
 506   1        if (state != 9 && (GetPlayerMode() == enumModePause || GetPlayerMode() == enumModePlay))
 507   1          SetPlayerMode(enumModeStop);
 508   1      
 509   1        /*¸Ã¹¦ÄÜ·ÏÖ¹
 510   1        //mode8: Ò£¿ØÄ£Ê½
 511   1        if (state == 10)
 512   1        {
 513   1          if (K2 == enumKeyPress)
 514   1          {
 515   1            if(IrTxdSet(&controller,22) == enumIrTxOK) SetBeep(1500,20);
 516   1          }
 517   1        }
 518   1        */
 519   1      
 520   1      }
 521          
 522          
 523          
 524          
 525          //¶¨Ê±»Øµ÷º¯Êý(ÓÃÓÚÏÔÊ¾ÊýÂë¹Ü)
 526          void my100mS_callback()
 527          {
 528   1        if (oled_change == 1)
 529   1        {
 530   2          oled_display();
 531   2          pc_preview();
 532   2          oled_change = 0;
 533   2        }
 534   1      
 535   1        //Ãë±íÄ£Ê½£¬ÔÚÃë±íÄ£Ê½Ö®ÍâÒ²¼ÆÊ±
 536   1        if(stopwatch_1 ==1)  time1++;
 537   1        if(stopwatch_2 ==1)  time2++;
 538   1      
 539   1        //¶¨Ê±Æ÷Ä£Ê½£¬ÔÚ¶¨Ê±Æ÷Ö®ÍâÒ²½øÐÐ
 540   1        if (timer_run == 1 ) timer--;
 541   1        if (timer == 0 && timer_change != 1)
 542   1        {
 543   2          timer_run = 0;
 544   2          SetBeep(1400,200);
 545   2          timer = 3000;
 546   2      
 547   2        }
 548   1      
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 10  

 549   1        switch(state)
 550   1        {
 551   2      
 552   2      
 553   2          //Vib´¦ÀíÄ£Ê½½çÃæ
 554   2          case 0:
 555   2          {
 556   3            Seg7Print(30,13,1,11,11,1,13,30);
 557   3            break;
 558   3          }
 559   2      
 560   2      
 561   2          //ÇÐ»»Ä£Ê½½çÃæ
 562   2          case 1:
 563   2          {
 564   3            if (transfer == 1)//state×ªÒÆ£¬ÐèÒª¸Ä±äÆÁÄ»
 565   3            {
 566   4              //OLED_ShowString(0, 6, "Next Mode£º", 16);//ÖÐ¼ä²½ÖèÊ¹ÓÃ
 567   4              transfer=0;
 568   4              oled_change=1;
 569   4            }
 570   3            Seg7Print(32,37,44,44,48,34,12,next_mode[previous_state]);
 571   3            LedPrint(0);
 572   3            break;
 573   3          }
 574   2      
 575   2      
 576   2          //³õÊ¼»¶Ó­½çÃæ:HNU-CSEE+Á÷Ë®µÆ
 577   2          case 2:
 578   2          {
 579   3            unsigned char a;
 580   3            Seg7Print(37,43,50,12,32,48,34,34);
 581   3      
 582   3            if( a != 0) a=a<<1;
 583   3              else a=0x01;
 584   3            LedPrint(a);
 585   3            break;
 586   3          }
 587   2      
 588   2      
 589   2          //Mode1:ÊµÊ±Ê±ÖÓ
 590   2          //³õÊ¼ÏÔÊ¾Ê±¼ä£¬Ê¹ÓÃK2¼üÒÀ´ÎÇÐ»»ÏÔÊ¾ Ê±·ÖÃë/ÄêÔÂÈÕ/ÐÇÆÚ(Ó¢ÎÄ+Êý×Ö)
 591   2          case 3:
 592   2          {
 593   3            rtc = RTC_Read();
 594   3            switch(clock_mode)
 595   3            {
 596   4              case 0:
 597   4              {
 598   5                Seg7Print(rtc.hour/16,rtc.hour%16,12,rtc.minute/16,rtc.minute%16,12,rtc.second/16,rtc.second%16);
 599   5                break;
 600   5              }
 601   4              case 1:
 602   4              {
 603   5                Seg7Print(rtc.year/16,rtc.year%16,12,rtc.month/16,rtc.month%16,12,rtc.day/16,rtc.day%16);
 604   5                break;
 605   5              }
 606   4              case 2:
 607   4              {
 608   5                unsigned char weekday = rtc.week;
 609   5                switch(weekday)
 610   5                {
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 11  

 611   6                  case 1:{Seg7Print(43,43,44,56,10,10,12,1); break;}
 612   6                  case 2:{Seg7Print(49,50,57,10,10,10,12,2); break;}
 613   6                  case 3:{Seg7Print(50,50,34,58,10,10,12,3); break;}
 614   6                  case 4:{Seg7Print(49,37,50,47,59,10,12,4); break;}
 615   6                  case 5:{Seg7Print(35,47,60,10,10,10,12,4); break;}
 616   6                  case 6:{Seg7Print(48,30,61,10,10,10,12,4); break;}
 617   6                  case 7:{Seg7Print(48,50,62,10,10,10,12,4); break;}
 618   6                }
 619   5                break;
 620   5              }
 621   4            }
 622   3      
 623   3            break;
 624   3          }
 625   2      
 626   2      
 627   2          //Mode2:Ë«Í¨µÀÃë±í
 628   2          //Ê¹ÓÃK3/K2¼ü·Ö±ð¶ÀÁ¢¼ÇÁ½¸ö±í£¬ÇÐ»»Ä£Ê½²»Ó°Ïì¼ÆÊ±£¬½«ÔÚºóÌ¨¼ÌÐø
 629   2          case 4:
 630   2          {
 631   3            unsigned char d0,d1,d2,d3,d4,d5,d6,d7;
 632   3      
 633   3            d7 = (time1/1000)%10; if (d7 == 0) d7 = 10;
 634   3            d6 = (time1/100)%10;  if (d6 == 0) d6 = 10;
 635   3            d5 = (time1/10)%10+20;//ÕâÀïÒªÏÔÊ¾Ð¡Êýµã
 636   3            d4 = (time1%10);
 637   3      
 638   3            d3 = (time2/1000)%10; if (d3 == 0) d3 = 10;
 639   3            d2 = (time2/100)%10;  if (d2 == 0) d2 = 10;
 640   3            d1 = (time2/10)%10+20;//ÕâÀïÒªÏÔÊ¾Ð¡Êýµã
 641   3            d0 = (time2%10);
 642   3      
 643   3            Seg7Print(d7,d6,d5,d4,d3,d2,d1,d0);
 644   3      
 645   3            break;
 646   3          }
 647   2      
 648   2      
 649   2          //Mode3:¶¨Ê±Æ÷
 650   2          case 5:
 651   2          {
 652   3            count++;
 653   3            if (count<=3)//ÓÃ¼ÆÊý·Ö¸îÊ±¼ä£¬´ï³ÉÉÁË¸Ð§¹û
 654   3            {
 655   4              Seg7Print(10,10,timer/10/60/10,timer/10/60%10,12,timer/10%60/10,timer/10%60%10+20,timer%10);
 656   4            }
 657   3            else
 658   3            {
 659   4              if (timer_change == 0)//Õý³£×´Ì¬ »ò ¼ÆÊýÄ£Ê½
 660   4              {
 661   5                if (timer_run == 0) Seg7Print(10,10,timer/10/60/10,timer/10/60%10,12,timer/10%60/10,timer/10%60%10+20
             -,timer%10);
 662   5                else if (timer_run == 1) Seg7Print(45,10,timer/10/60/10,timer/10/60%10,12,timer/10%60/10,timer/10%60%
             -10+20,timer%10);
 663   5              }
 664   4              else if (timer_minute == 1)//µ÷½Ú·ÖÖÓ£¬·ÖÖÓÉÁË¸
 665   4              {
 666   5                Seg7Print(32,10,10,10,12,timer/10%60/10,timer/10%60%10+20,timer%10);
 667   5              }
 668   4              else if (timer_second == 1)//µ÷½ÚÃëÖÓ£¬ÃëÖÓÉÁË¸
 669   4              {
 670   5                Seg7Print(32,10,timer/10/60/10,timer/10/60%10,12,10,10,10);
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 12  

 671   5              }
 672   4            }
 673   3            if (count > 5) count=0;
 674   3            break;
 675   3          }
 676   2      
 677   2      
 678   2          //Mode4:¹âÕÕ¼à²âÓë±¨¾¯
 679   2          case 6:
 680   2          {
 681   3            unsigned int num = GetADC().Rop;
 682   3      
 683   3            if (light_intensity_change == 0)//Õý³£Ä£Ê½
 684   3            {
 685   4              Seg7Print(34,4,12,10,10,num/100,num/10%10,num%10);
 686   4              if (light_intensity_mode == 1)
 687   4              {
 688   5                if (num < light_intensity_lowerlimit)
 689   5                {
 690   6                  SetBeep(1200,200);
 691   6                }
 692   5                else if (num > light_intensity_upperlimit)
 693   5                {
 694   6                  SetBeep(2000,200);
 695   6                }
 696   5              }
 697   4            }
 698   3            else if (light_intensity_change == 1)//changeÄ£Ê½
 699   3            {
 700   4              count++;
 701   4      
 702   4              if (count<=3)//ÓÃ¼ÆÊý·Ö¸îÊ±¼ä£¬´ï³ÉÉÁË¸Ð§¹û
 703   4              {
 704   5                Seg7Print(light_intensity_mode,
 705   5                          light_intensity_lowerlimit/100%10,
 706   5                          light_intensity_lowerlimit/10%10,
 707   5                          light_intensity_lowerlimit%10,
 708   5                          12,
 709   5                          light_intensity_upperlimit/100%10,
 710   5                          light_intensity_upperlimit/10%10,
 711   5                          light_intensity_upperlimit%10);
 712   5              }
 713   4              else
 714   4              {
 715   5                if (light_intensity_lowerlimit_change == 1) //ÏÂÏÞ¸Ä¶¯
 716   5                {
 717   6                  Seg7Print(light_intensity_mode,
 718   6                          10,10,10,
 719   6                          12,
 720   6                          light_intensity_upperlimit/100%10,
 721   6                          light_intensity_upperlimit/10%10,
 722   6                          light_intensity_upperlimit%10);
 723   6                }
 724   5                else if (light_intensity_upperlimit_change == 1) //ÉÏÏÞ¸Ä¶¯
 725   5                {
 726   6                  Seg7Print(light_intensity_mode,
 727   6                          light_intensity_lowerlimit/100%10,
 728   6                          light_intensity_lowerlimit/10%10,
 729   6                          light_intensity_lowerlimit%10,
 730   6                          12,
 731   6                          10,10,10);
 732   6                }
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 13  

 733   5                else if (light_intensity_mode_change == 1) //Ä£Ê½¸Ä¶¯
 734   5                {
 735   6                  Seg7Print(10,
 736   6                          light_intensity_lowerlimit/100%10,
 737   6                          light_intensity_lowerlimit/10%10,
 738   6                          light_intensity_lowerlimit%10,
 739   6                          12,
 740   6                          light_intensity_upperlimit/100%10,
 741   6                          light_intensity_upperlimit/10%10,
 742   6                          light_intensity_upperlimit%10);
 743   6                }
 744   5              }
 745   4              if (count > 5) count=0;
 746   4            }
 747   3      
 748   3            break;
 749   3          }
 750   2      
 751   2      
 752   2          //Mode5:ÎÂ¶È¼à²âÓë±¨¾¯
 753   2          case 7:
 754   2          {
 755   3            unsigned int tem_adc = GetADC().Rt;
 756   3            unsigned int tem = tem_calculate(tem_adc);
 757   3      
 758   3            if (temperature_change == 0)//Õý³£Ä£Ê½
 759   3            {
 760   4              Seg7Print(34,5,12,10,10,tem/100%10,20+tem/10%10,tem%10);
 761   4              //µÚ¶þÎ»ÏÔÊ¾Ð¡Êýµã
 762   4              if (temperature_mode == 1)
 763   4              {
 764   5                if (tem/10 < 20)
 765   5                {
 766   6                  SetBeep(1200,200);
 767   6                }
 768   5                else if (tem/10 > 40)
 769   5                {
 770   6                  SetBeep(2000,200);
 771   6                }
 772   5              }
 773   4            }
 774   3            else if (temperature_change == 1)//changeÄ£Ê½
 775   3            {
 776   4              count++;
 777   4      
 778   4              if (count<=3)//ÓÃ¼ÆÊý·Ö¸îÊ±¼ä£¬´ï³ÉÉÁË¸Ð§¹û
 779   4              {
 780   5                Seg7Print(temperature_mode,
 781   5                          temperature_lowerlimit/100%10,
 782   5                          20+temperature_lowerlimit/10%10,
 783   5                          temperature_lowerlimit%10,
 784   5                          12,
 785   5                          temperature_upperlimit/100%10,
 786   5                          20+temperature_upperlimit/10%10,
 787   5                          temperature_upperlimit%10);
 788   5              }
 789   4              else
 790   4              {
 791   5                if (temperature_lowerlimit_change == 1) //ÏÂÏÞ¸Ä¶¯
 792   5                {
 793   6                  Seg7Print(temperature_mode,
 794   6                          10,10,10,
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 14  

 795   6                          12,
 796   6                          temperature_upperlimit/100%10,
 797   6                          20+temperature_upperlimit/10%10,
 798   6                          temperature_upperlimit%10);
 799   6                }
 800   5                else if (temperature_upperlimit_change == 1) //ÉÏÏÞ¸Ä¶¯
 801   5                {
 802   6                  Seg7Print(temperature_mode,
 803   6                          temperature_lowerlimit/100%10,
 804   6                          20+temperature_lowerlimit/10%10,
 805   6                          temperature_lowerlimit%10,
 806   6                          12,
 807   6                          10,10,10);
 808   6                }
 809   5                else if (temperature_mode_change == 1) //Ä£Ê½¸Ä¶¯
 810   5                {
 811   6                  Seg7Print(10,
 812   6                          temperature_lowerlimit/100%10,
 813   6                          20+temperature_lowerlimit/10%10,
 814   6                          temperature_lowerlimit%10,
 815   6                          12,
 816   6                          temperature_upperlimit/100%10,
 817   6                          20+temperature_upperlimit/10%10,
 818   6                          temperature_upperlimit%10);
 819   6                }
 820   5              }
 821   4              if (count > 5) count=0;
 822   4            }
 823   3      
 824   3              break;
 825   3          }
 826   2      
 827   2      
 828   2          //Mode6:FMÊÕÒô»ú
 829   2          //°´K1»òK2½øÈëÑ¡ÖÐ×´Ì¬£¬·Ö±ðµ÷½ÚÒôÁ¿ºÍÆµÂÊ£¬°´ÉÏÏÂµ¼º½¼üµ÷½ÚÖµ´óÐ¡
 830   2          case 8:
 831   2          {
 832   3            unsigned int frequency = GetFMRadio().frequency;
 833   3            unsigned char volume = GetFMRadio().volume;
 834   3            unsigned char fre0,fre1,fre2,vol0,vol1;
 835   3            fre0 = frequency%10;
 836   3            fre1 = frequency/10%10+20;
 837   3            fre2 = frequency/100%10; if (fre2 == 0) fre2 = 10;
 838   3            vol0 = volume%10;
 839   3            vol1 = volume/10%10;
 840   3            count++;
 841   3            if (count<=3)//ÓÃ¼ÆÊý·Ö¸îÊ±¼ä£¬´ï³ÉÉÁË¸Ð§¹û
 842   3            {
 843   4              Seg7Print(50,vol1,vol0,10,35,fre2,fre1,fre0);
 844   4            }
 845   3            else
 846   3            {
 847   4              if (FM_frequency == 0 && FM_volume == 0)//Õý³£Çé¿ö
 848   4              {
 849   5                Seg7Print(50,vol1,vol0,10,35,fre2,fre1,fre0);
 850   5              }
 851   4              else if (FM_frequency == 1)//µ÷½ÚÆµÂÊ£¬ÆµÂÊÉÁË¸
 852   4              {
 853   5                Seg7Print(50,vol1,vol0,10,35,10,10,10);
 854   5              }
 855   4              else if (FM_volume == 1)//µ÷½ÚÒôÁ¿£¬ÒôÁ¿ÉÁË¸
 856   4              {
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 15  

 857   5                Seg7Print(50,10,10,10,35,fre2,fre1,fre0);
 858   5              }
 859   4            }
 860   3            if (count > 5) count=0;
 861   3            break;
 862   3          }
 863   2      
 864   2      
 865   2          //Mode7:MP3
 866   2          case 9:
 867   2          {
 868   3            if (GetPlayerMode() == enumModeStop) Seg7Print(34,7,12,10,10,10,10,10);
 869   3            if (GetPlayerMode() == enumModePause) Seg7Print(45,30,50,48,34,10,10,10);
 870   3            break;
 871   3          }
 872   2      
 873   2          /*¸Ã¹¦ÄÜ×îºóÃ»ÓÐÊµÏÖ
 874   2          //Mode8:£¨¸ñÁ¦£©¿Õµ÷Ò£¿Ø
 875   2          case 10:
 876   2          {
 877   2            Seg7Print(12,12,43,44,12,8,12,12);
 878   2            break;
 879   2          }
 880   2          */
 881   2      
 882   2          default:
 883   2          {
 884   3            //do nothing
 885   3            break;
 886   3          }
 887   2      
 888   2        };
 889   1      
 890   1      }
 891          
 892          //Õð¶¯ÊÂ¼þ»Øµ÷º¯Êý
 893          void myVib_callback()
 894          {
 895   1        if (state != 0) vib_old_state = state;//¼ÓÅÐ¶ÏÌõ¼þ·ÀÖ¹Á¬Ðø×²»÷µ¼ÖÂstate±äÎª0£¬ËøËÀ³ö²»È¥
 896   1        state = 0;
 897   1        SetBeep(600,10);
 898   1        oled_change = 1;
 899   1      }
 900          
 901          //ÎÂ¶È×ª»»¸¨Öúº¯Êý
 902          unsigned int tem_calculate(unsigned int tem_adc)
 903          {
 904   1        float vccx=tem_adc/1000.0;
 905   1        float lnx=log(vccx/(1-vccx));
 906   1        float tem=1/((lnx/3950)+(1/298.15))-273.15;
 907   1        float tem10=tem*10;
 908   1        unsigned int ans=(int)tem10;
 909   1        return ans;
 910   1      }
 911          
 912          //oledÏÔÊ¾ÆÁÇÐ»»
 913          void oled_display()
 914          {
 915   1        OLED_Clear();
 916   1        //OLED_ColorTurn(0);
 917   1        switch(state)
 918   1        {
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 16  

 919   2          case 0:
 920   2          {
 921   3            //Õð¶¯¾¯¸æ
 922   3            OLED_DrawBMP1(0, 0, 64, 64, vib_avater);
 923   3            OLED_ShowString(0, 0, "  Vib Detected  ", 16);
 924   3            OLED_ShowCHinese(64, 3, 29);
 925   3            OLED_ShowCHinese(80, 3, 30);
 926   3            OLED_ShowCHinese(96, 3, 31);
 927   3            OLED_ShowCHinese(112, 3, 32);
 928   3            break;
 929   3          }
 930   2          case 1:
 931   2          {
 932   3            //Ñ¡ÔñÄ£Ê½
 933   3            OLED_DrawBMP1(0, 0, 64, 64, choose_avater);
 934   3            OLED_ShowString(0, 0, "CHOOSE YOUR MODE", 16);
 935   3            OLED_ShowCHinese(64, 3, 33);
 936   3            OLED_ShowCHinese(80, 3, 34);
 937   3            OLED_ShowCHinese(96, 3, 35);
 938   3            OLED_ShowCHinese(112, 3, 36);
 939   3            break;
 940   3          }
 941   2          case 2:
 942   2          {
 943   3            //ÓÉ³õÊ¼»¯º¯Êý´úÎª´¦Àí£¬´Ë´¦²»×÷²Ù×÷
 944   3            break;
 945   3          }
 946   2          case 3:
 947   2          {
 948   3            //MODE-1 ÊµÊ±Ê±ÖÓ
 949   3            OLED_DrawBMP1(0, 0, 64, 64, clock_avater);
 950   3            OLED_ShowString(0, 0, " MODE:01  CLOCK ", 16);
 951   3            OLED_ShowCHinese(64, 3, 0);
 952   3            OLED_ShowCHinese(80, 3, 1);
 953   3            OLED_ShowCHinese(96, 3, 2);
 954   3            OLED_ShowCHinese(112, 3, 3);
 955   3            break;
 956   3          }
 957   2          case 4:
 958   2          {
 959   3            //MODE-2 Ë«Í¨µÀÃë±í
 960   3            OLED_DrawBMP1(0, 0, 64, 64, stopwatch_avater);
 961   3            OLED_ShowString(0, 0, "MODE:02STOPWATCH", 16);
 962   3            OLED_ShowCHinese(64, 3, 4);
 963   3            OLED_ShowCHinese(80, 3, 5);
 964   3            OLED_ShowCHinese(96, 3, 6);
 965   3            OLED_ShowCHinese(64, 5, 7);
 966   3            OLED_ShowCHinese(80, 5, 8);
 967   3            break;
 968   3          }
 969   2          case 5:
 970   2          {
 971   3            //MODE-3 ¶¨Ê±Æ÷
 972   3            OLED_DrawBMP1(0, 0, 64, 64, timer_avater);
 973   3            OLED_ShowString(0, 0, " MODE:03  TIMER ", 16);
 974   3            OLED_ShowCHinese(64, 3, 9);
 975   3            OLED_ShowCHinese(80, 3, 10);
 976   3            OLED_ShowCHinese(96, 3, 11);
 977   3            break;
 978   3          }
 979   2          case 6:
 980   2          {
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 17  

 981   3            //MODE-4 ¹â¸Ð¼à²âÓë±¨¾¯
 982   3            OLED_DrawBMP1(0, 0, 64, 64, light_avater);
 983   3            OLED_ShowString(0, 0, " MODE:04 light  ", 16);
 984   3            OLED_ShowCHinese(64, 3, 12);
 985   3            OLED_ShowCHinese(80, 3, 13);
 986   3            OLED_ShowCHinese(96, 3, 14);
 987   3            OLED_ShowCHinese(112, 3, 15);
 988   3            OLED_ShowCHinese(64, 5, 16);
 989   3            OLED_ShowCHinese(80, 5, 17);
 990   3            OLED_ShowCHinese(96, 5, 18);
 991   3            break;
 992   3          }
 993   2          case 7:
 994   2          {
 995   3            //MODE-5 ÎÂ¶È¼à²âÓë±¨¾¯
 996   3            OLED_DrawBMP1(0, 0, 64, 64, temperature_avater);
 997   3            OLED_ShowString(0, 0, " MODE:05  Temp  ", 16);
 998   3            OLED_ShowCHinese(64, 3, 19);
 999   3            OLED_ShowCHinese(80, 3, 20);
1000   3            OLED_ShowCHinese(96, 3, 21);
1001   3            OLED_ShowCHinese(112, 3, 22);
1002   3            OLED_ShowCHinese(64, 5, 23);
1003   3            OLED_ShowCHinese(80, 5, 24);
1004   3            OLED_ShowCHinese(96, 5, 25);
1005   3            break;
1006   3          }
1007   2          case 8:
1008   2          {
1009   3            //MODE-6 ÊÕÒô»úFM
1010   3            OLED_DrawBMP1(0, 0, 64, 64, FM_avater);
1011   3            OLED_ShowString(0, 0, " MODE:06   FM   ", 16);
1012   3            OLED_ShowCHinese(64, 3, 26);
1013   3            OLED_ShowCHinese(80, 3, 27);
1014   3            OLED_ShowCHinese(96, 3, 28);
1015   3            break;
1016   3          }
1017   2          case 9:
1018   2          {
1019   3            //MODE-7 ÒôÀÖ
1020   3            //OLED_ColorTurn(1);
1021   3            OLED_DrawBMP1(0, 0, 64, 64, music_avater);
1022   3            OLED_ShowString(0, 0, " MODE:07  MUSIC ", 16);
1023   3            break;
1024   3          }
1025   2          default:
1026   2          {
1027   3            //do nothing
1028   3            break;
1029   3          }
1030   2        }
1031   1      }
1032          
1033          //Í¨ÐÅ½ÓÊÕ»Øµ÷º¯Êý
1034          void uart_callback()
1035          {
1036   1        //if (datanow[2] == 0x00) SetBeep(200,10);
1037   1        Uart1Print(back,6);
1038   1        SetBeep(2000,10);
1039   1      }
1040          
1041          //¼ÆËã»úÕ¹Ê¾
1042          void pc_preview()
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 18  

1043          {
1044   1        switch(state)
1045   1        {
1046   2          case 0:
1047   2          {
1048   3            //Õð¶¯¾¯¸æ
1049   3            code char vib_pc_1[]={0xaa,0x55,0x10,0x00,0x00,0x00};
1050   3            code char vib_pc_2[]={0xaa,0x55,0x20,0x00,0x00,0x00};
1051   3            code char vib_pc_3[]={0xaa,0x55,0x30,0x00,0x00,0x00};
1052   3            code char vib_pc_4[]={0xaa,0x55,0x40,0x00,0x00,0x00};
1053   3            code char vib_pc_5[]={0xaa,0x55,0x50,0x00,0x00,0x00};
1054   3            code char vib_pc_6[]={0xaa,0x55,0x60,0x00,0x00,0x00};
1055   3            code char vib_pc_7[]={0xaa,0x55,0x70,0x00,0x00,0x00};
1056   3            code char vib_pc_8[]={0xaa,0x55,0x80,0x00,0x00,0x00};
1057   3            code char vib_pc_9[]={0xaa,0x55,0x90,0x00,0x00,0x00};
1058   3            switch (vib_old_state)
1059   3            {
1060   4              case 1: {Uart1Print(vib_pc_1,6); break; }
1061   4              case 2: {Uart1Print(vib_pc_2,6); break; }
1062   4              case 3: {Uart1Print(vib_pc_3,6); break; }
1063   4              case 4: {Uart1Print(vib_pc_4,6); break; }
1064   4              case 5: {Uart1Print(vib_pc_5,6); break; }
1065   4              case 6: {Uart1Print(vib_pc_6,6); break; }
1066   4              case 7: {Uart1Print(vib_pc_7,6); break; }
1067   4              case 8: {Uart1Print(vib_pc_8,6); break; }
1068   4              case 9: {Uart1Print(vib_pc_9,6); break; }
1069   4              default: {break;}
1070   4            }
1071   3            break;
1072   3          }
1073   2          case 1:
1074   2          {
1075   3            //Ñ¡ÔñÄ£Ê½
1076   3            code char choose_pc_2[]={0xaa,0x55,0x3a,0x00,0x00,0x00};
1077   3            code char choose_pc_3[]={0xaa,0x55,0x4a,0x00,0x00,0x00};
1078   3            code char choose_pc_4[]={0xaa,0x55,0x5a,0x00,0x00,0x00};
1079   3            code char choose_pc_5[]={0xaa,0x55,0x6a,0x00,0x00,0x00};
1080   3            code char choose_pc_6[]={0xaa,0x55,0x7a,0x00,0x00,0x00};
1081   3            code char choose_pc_7[]={0xaa,0x55,0x8a,0x00,0x00,0x00};
1082   3            code char choose_pc_8[]={0xaa,0x55,0x9a,0x00,0x00,0x00};
1083   3            code char choose_pc_9[]={0xaa,0x55,0x3a,0x00,0x00,0x00};
1084   3            switch (previous_state)
1085   3            {
1086   4              case 2: {Uart1Print(choose_pc_2,6); break; }
1087   4              case 3: {Uart1Print(choose_pc_3,6); break; }
1088   4              case 4: {Uart1Print(choose_pc_4,6); break; }
1089   4              case 5: {Uart1Print(choose_pc_5,6); break; }
1090   4              case 6: {Uart1Print(choose_pc_6,6); break; }
1091   4              case 7: {Uart1Print(choose_pc_7,6); break; }
1092   4              case 8: {Uart1Print(choose_pc_8,6); break; }
1093   4              case 9: {Uart1Print(choose_pc_9,6); break; }
1094   4              default: {break;}
1095   4            }
1096   3            break;
1097   3          }
1098   2          case 2:
1099   2          {
1100   3            code char welcome_pc[]={0xaa,0x55,0xa1,0xa1,0xa1,0xa1};
1101   3            Uart1Print(welcome_pc,6);
1102   3            break;
1103   3          }
1104   2          case 3:
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 19  

1105   2          {
1106   3            //MODE-1 ÊµÊ±Ê±ÖÓ
1107   3            code char clock_pc[]={0xaa,0x55,0x01,0x00,0x00,0x00};
1108   3            Uart1Print(clock_pc,6);
1109   3            break;
1110   3          }
1111   2          case 4:
1112   2          {
1113   3            //MODE-2 Ë«Í¨µÀÃë±í
1114   3            code char stopwatch_pc[]={0xaa,0x55,0x02,0x00,0x00,0x00};
1115   3            Uart1Print(stopwatch_pc,6);
1116   3            break;
1117   3          }
1118   2          case 5:
1119   2          {
1120   3            //MODE-3 ¶¨Ê±Æ÷
1121   3            code char timer_pc[]={0xaa,0x55,0x03,0x00,0x00,0x00};
1122   3            Uart1Print(timer_pc,6);
1123   3            break;
1124   3          }
1125   2          case 6:
1126   2          {
1127   3            //MODE-4 ¹â¸Ð¼à²âÓë±¨¾¯
1128   3            code char light_pc[]={0xaa,0x55,0x04,0x00,0x00,0x00};
1129   3            Uart1Print(light_pc,6);
1130   3            break;
1131   3          }
1132   2          case 7:
1133   2          {
1134   3            //MODE-5 ÎÂ¶È¼à²âÓë±¨¾¯
1135   3            code char temperature_pc[]={0xaa,0x55,0x05,0x00,0x00,0x00};
1136   3            Uart1Print(temperature_pc,6);
1137   3            break;
1138   3          }
1139   2          case 8:
1140   2          {
1141   3            //MODE-6 ÊÕÒô»úFM
1142   3            code char FM_pc[]={0xaa,0x55,0x06,0x00,0x00,0x00};
1143   3            Uart1Print(FM_pc,6);
1144   3            break;
1145   3          }
1146   2          case 9:
1147   2          {
1148   3            //MODE-7 ÒôÀÖ
1149   3            code char music_pc[]={0xaa,0x55,0x07,0x00,0x00,0x00};
1150   3            Uart1Print(music_pc,6);
1151   3            break;
1152   3          }
1153   2          default:
1154   2          {
1155   3            //do nothing
1156   3            break;
1157   3          }
1158   2        }
1159   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5492    ----
   CONSTANT SIZE    =   6950    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   MAIN                                                                  09/07/2023 20:24:04 PAGE 20  

   DATA SIZE        =     24      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
